package nl.photoreality.panorama.view.panorama {
	
	import alternativa.engine3d.core.VertexAttributes;
	import alternativa.engine3d.materials.Material;
	import alternativa.engine3d.objects.Mesh;
	import alternativa.engine3d.resources.Geometry;
	
	/**
	 * ???????.
	 */ 
	public class Cylinder extends Mesh {
		/**
		 * ???????? ????????.
		 */
		private var _material:Material;
		
		/**
		 * ?????? ??????? ????? ????????.
		 */
		protected var _topRadius : Number;
		
		/**
		 * ?????? ?????? ????? ????????.
		 */
		protected var _bottomRadius : Number;
		
		/**
		 * ?????? ????????.
		 */
		protected var _height : Number;
		
		/**
		 * ?????????? ?????????? ????????? ?? ??????????? ?? ??????? ????? ???????? ???????. ???????? ?? ????????? ????? 16.
		 */
		protected var _segmentsW : uint;
		
		/**
		 * ?????????? ?????????? ????????? ?? ????????? ?? ??????? ????? ???????? ???????. ???????? ?? ????????? ????? 1.
		 */
		protected var _segmentsH : uint;
		
		/**
		 * ?????????? ????? ?? ??????? ????? ???????? ???????? (true) ??? ????????.
		 */
		protected var _topClosed : Boolean;
		
		/**
		 * ?????????? ????? ?? ?????? ????? ???????? ???????? (true) ??? ????????.
		 */
		protected var _bottomClosed : Boolean;
		
		/**
		 * ?????????? ????? ?? ??????????? ???????? ????????? (true) ??? ?????????.
		 */
		protected var _surfaceClosed: Boolean;
		
		/**
		 * ?????????? ??? ????? ?????? ?????? ????????, ?? ??? Y(true) ??? ?? ??? Z(false).
		 */
		protected var _yUp : Boolean;
		
		/**
		 * Stream.
		 */
		private var _attributes:Array;
		
		/**
		 * ?????? ? ???????????? ?????? ????????
		 */ 
		private var _rawVertexPositions:Vector.<Number>;
		
		/**
		 * ?????? ? ????????? ?????? ????????
		 */ 
		private var _rawVertexNormals:Vector.<Number>;
		
		/**
		 * ?????? ? ?????????? ?????? ????????
		 */ 
		private var _rawVertexTangents:Vector.<Number>;
		
		/**
		 * ?????? ? UV-???????????? ?????? ????????
		 */ 
		private var _rawUvs:Vector.<Number>;
		
		/**
		 * ?????? ? ????????? ?????? ????????
		 */ 
		private var _rawIndices:Vector.<uint>;
		
		/**
		 * ????????? ?????? ???????.
		 */
		private var _nextVertexIndex:uint;
		
		/**
		 * ??????? ?????? ???????.
		 */
		private var _currentIndex:uint;
		
		/**
		 * ??????? ?????? ????????????.
		 */
		private var _currentTriangleIndex:uint;
		
		/**
		 * ???????? ???????? ??????? ???????.
		 */
		private var _vertexIndexOffset:uint;
		
		/**
		 * ???????? ?????????? ??????
		 */
		private var _numVertices:uint;
		
		/**
		 * ???????? ?????????? ?????????????
		 */
		private var _numTriangles:uint;
		
		
		private var _reverse:Boolean;
		
		/**
		 * ??????????? ????????.
		 * @param topRadius ?????? ??????? ????? ????????.
		 * @param bottomRadius ?????? ?????? ????? ????????.
		 * @param height ?????? ????????.
		 * @param segmentsW ?????????? ?????????? ????????? ?? ??????????? ?? ??????? ????? ???????? ???????. ???????? ?? ????????? ????? 16.
		 * @param segmentsH ?????????? ?????????? ????????? ?? ????????? ?? ??????? ????? ???????? ???????. ???????? ?? ????????? ????? 1.
		 * @param topClosed ?????????? ????? ?? ??????? ????? ???????? ???????? (true) ??? ????????.
		 * @param bottomClosed ?????????? ????? ?? ?????? ????? ???????? ???????? (true) ??? ????????.
		 * @param surfaceClosed ?????????? ????? ?? ??????????? ???????? ????????? (true) ??? ?????????.
		 * @param yUp ?????????? ??? ????? ?????? ?????? ????????, ?? ??? Y(true) ??? ?? ??? Z(false).
		 * @param material ????????, c ??????? ????? ?????????? ???????.
		 */
		public function Cylinder(topRadius : Number = 50, bottomRadius : Number = 50, height : Number = 100, segmentsW : uint = 16, segmentsH : uint = 1, topClosed:Boolean = true, bottomClosed:Boolean = true, surfaceClosed:Boolean = true, yUp : Boolean = true, reverse:Boolean = false, material : Material = null) {
			super(); //???????? ??????????? ?????? Mesh
			
			_material = material; 
			_topRadius = topRadius;
			_bottomRadius = bottomRadius;
			_height = height; 
			_segmentsW = segmentsW; 
			_segmentsH = segmentsH; 
			_topClosed = topClosed;
			_bottomClosed = bottomClosed;
			_surfaceClosed = surfaceClosed; 
			_yUp = yUp; 
			_reverse = reverse;
			
			createStream();
			buildGeometry();
			buildUV();
		}
		
		/**
		 * ??????? Stream.
		 */
		private function createStream():void {
			_attributes = [
						  VertexAttributes.POSITION,
						  VertexAttributes.POSITION,
						  VertexAttributes.POSITION,
						  VertexAttributes.TEXCOORDS[0],
						  VertexAttributes.TEXCOORDS[0],
						  VertexAttributes.NORMAL,
						  VertexAttributes.NORMAL,
						  VertexAttributes.NORMAL,
						  VertexAttributes.TANGENT4,
						  VertexAttributes.TANGENT4,
						  VertexAttributes.TANGENT4,
						  VertexAttributes.TANGENT4
						];
		}
		
		/**
		 * ????????? ? ??????? ?????? ??????? ???????, ?? ??????? ? ???????-??????
		 */
		private function addVertex(px:Number, py:Number, pz:Number,
								   nx:Number, ny:Number, nz:Number,
								   tx:Number, ty:Number, tz:Number, bi:Number):void {
			var compVertInd:uint = _nextVertexIndex * 3; // ??????? ?????? ???????
			_rawVertexPositions[compVertInd]     = px;
			_rawVertexPositions[compVertInd + 1] = py;
			_rawVertexPositions[compVertInd + 2] = pz;
			_rawVertexNormals[compVertInd]       = nx;
			_rawVertexNormals[compVertInd + 1]   = ny;
			_rawVertexNormals[compVertInd + 2]   = nz;
			_rawVertexTangents[compVertInd]      = tx;
			_rawVertexTangents[compVertInd + 1]  = ty;
			_rawVertexTangents[compVertInd + 2]  = tz;
			_rawVertexTangents[compVertInd + 3]  = bi;
			_nextVertexIndex++;
		}
		
		/**
		 * ????????? ??????? ?????? ????????????.
		 */
		private function addTriangleClockWise(cwVertexIndex0:uint, cwVertexIndex1:uint, cwVertexIndex2:uint):void {
			if (_reverse) {
				_rawIndices[_currentIndex++] = cwVertexIndex2;
				_rawIndices[_currentIndex++] = cwVertexIndex1;
				_rawIndices[_currentIndex++] = cwVertexIndex0;
				
			} else {
				_rawIndices[_currentIndex++] = cwVertexIndex0;
				_rawIndices[_currentIndex++] = cwVertexIndex1;
				_rawIndices[_currentIndex++] = cwVertexIndex2;
			}
			_currentTriangleIndex++;
		}
		
		/**
		 * C?????? ????????? ????????.
		 */
		private function buildGeometry():void { 
			var i:uint, j:uint;
			var x:Number, y:Number, z:Number, radius:Number, revolutionAngle:Number;

			// ?????????? ???????? ??????????????? ??????????
			_numVertices = 0;
			_numTriangles = 0;
			_nextVertexIndex = 0;
			_currentIndex = 0;
			_currentTriangleIndex = 0;

			// ??????? ???????? ????? ??????, ????????????? ? ????????
			if(_surfaceClosed) {
				_numVertices += (_segmentsH + 1) * (_segmentsW + 1); // segmentsH + 1 ??-?? ???????? ????????????, segmentsW + 1 ??-?? UV ?????????
				_numTriangles += _segmentsH * _segmentsW * 2; // ?????? ??????? ????? segmentW ?????????, ?????? ?? ???????? ??????? ?? 2 ?????????????
			}
			if(_topClosed) {
				_numVertices += 2 * (_segmentsW + 1); // segmentsW + 1 ??-?? ?????????
				_numTriangles += _segmentsW; // ???? ??????????? ?? ?????? ???????
			}
			if(_bottomClosed) {
				_numVertices += 2 * (_segmentsW + 1);
				_numTriangles += _segmentsW;
			}

			var numVertComponents:uint = _numVertices * 3;
			_rawVertexPositions = new Vector.<Number>(numVertComponents, true);
			_rawVertexNormals = new Vector.<Number>(numVertComponents, true);
			_rawVertexTangents = new Vector.<Number>(_numVertices * 4, true);
			_rawIndices = new Vector.<uint>(_numTriangles * 3, true);

			// ??????? ??? ????????
			var revolutionAngleDelta:Number = 2 * Math.PI / _segmentsW;

			// ???
			if (_bottomClosed) {

				z = -0.5 * _height;

				for (i = 0; i <= _segmentsW; ++i) {
					// ??????????? ???????
					if(_yUp)
						addVertex(0, -z, 0,   0, 1, 0,   1, 0, 0, 1);
					else
						addVertex(0, 0, z,   0, 0, -1,   1, 0, 0, 1);

					// ??????? ???????
					revolutionAngle = i * revolutionAngleDelta;
					x = _bottomRadius * Math.cos(revolutionAngle);
					y = _bottomRadius * Math.sin(revolutionAngle);
					if(_yUp)
						addVertex(x, -z, y,   0, 1, 0,   1, 0, 0, 1);
					else
						addVertex(x, y, z,   0, 0, -1,   1, 0, 0, 1);

					if(i > 0) // ????????? ???????????
						addTriangleClockWise(_nextVertexIndex - 1, _nextVertexIndex - 3, _nextVertexIndex - 2);
				}

				_vertexIndexOffset = _nextVertexIndex;
			}

			// ????
			if (_topClosed) {

				z = 0.5 * _height;

				for (i = 0; i <= _segmentsW; ++i)
				{
					// ??????????? ???????
					if(_yUp)
						addVertex(0, -z, 0,   0, -1, 0,   1, 0, 0, 1);
					else
						addVertex(0, 0, z,   0, 0, 1,   1, 0, 0, 1);

					// ??????? ???????
					revolutionAngle = i * revolutionAngleDelta;
					x = _topRadius * Math.cos(revolutionAngle);
					y = _topRadius * Math.sin(revolutionAngle);
					if(_yUp)
						addVertex(x, -z, y,   0, -1, 0,   1, 0, 0, 1);
					else
						addVertex(x, y, z,   0, 0, 1,   1, 0, 0, 1);

					if(i > 0) // ????????? ???????????
						addTriangleClockWise(_nextVertexIndex - 2, _nextVertexIndex - 3, _nextVertexIndex - 1);
				}

				_vertexIndexOffset = _nextVertexIndex;
			}

			// ??????? ???????????
			if(_surfaceClosed) {
				var a:uint, b:uint, c:uint, d:uint;

				for(j = 0; j <= _segmentsH; ++j)
				{
					radius = _bottomRadius - ((j / _segmentsH) * (_bottomRadius - _topRadius));
					z = -(_height / 2) + (j / _segmentsH * _height);

					for(i = 0; i <= _segmentsW; ++i)
					{
						// ??????? ???????
						revolutionAngle = i * revolutionAngleDelta;
						x = radius * Math.cos(revolutionAngle);
						y = radius * Math.sin(revolutionAngle);
						var tanLen:Number = Math.sqrt(y * y + x * x);
						if(_yUp)
							addVertex(x, -z, y,
									  x / tanLen, 0, y / tanLen,
									  tanLen > .007 ? -y / tanLen : 1, 0, tanLen > .007 ? x / tanLen : 0, 1);
						else
							addVertex(x, y, z,
									  x / tanLen, y / tanLen, 0,
									  tanLen > .007 ? -y / tanLen : 1, tanLen > .007 ? x / tanLen : 0, 0, 1);

						// ????????? ???????????
						if(i > 0 && j > 0)
						{
							a = _nextVertexIndex - 1; // ???????
							b = _nextVertexIndex - 2; // ??????????
							c = b - _segmentsW - 1; // ?????????? ?????????? ??????
							d = a - _segmentsW - 1; // ??????? ?????????? ??????
							addTriangleClockWise(a, b, c);
							addTriangleClockWise(a, c, d);
						}
					}
				}
			}
			
			// ??????? ???????? ?????? ?? ????? ??????
			geometry = new Geometry();
			geometry.numVertices = _numVertices;
			geometry.indices = _rawIndices;
			geometry.addVertexStream(_attributes);
			geometry.setAttributeValues(VertexAttributes.POSITION, _rawVertexPositions);
			geometry.setAttributeValues(VertexAttributes.NORMAL, _rawVertexNormals);
			geometry.setAttributeValues(VertexAttributes.TANGENT4, _rawVertexTangents);
		}
		
		/**
		 * C?????? UV
		 */
		private function buildUV():void { 
			var i:int, j:int;
			var x:Number, y:Number, revolutionAngle:Number;

			// ??????? ?????????? UV
			var numUvs:uint = _numVertices * 2;

			_rawUvs = new Vector.<Number>(numUvs, true);

			// ??????? ??? ????????
			var revolutionAngleDelta:Number = 2 * Math.PI / _segmentsW;

			// ??????? ?????? UV
			var currentUvCompIndex:uint = 0;

			// ????
			if (_topClosed) {
				for (i = 0; i <= _segmentsW; ++i) {

					revolutionAngle = i * revolutionAngleDelta;
					x = 0.5 + 0.5 * Math.cos(revolutionAngle);
					y = 0.5 + 0.5 * Math.sin(revolutionAngle);

					_rawUvs[currentUvCompIndex++] = 0.5; // ??????????? ???????
					_rawUvs[currentUvCompIndex++] = 0.5;
					_rawUvs[currentUvCompIndex++] = x; // ??????? ???????
					_rawUvs[currentUvCompIndex++] = y;
				}
			}

			// ???
			if (_bottomClosed) {
				for (i = 0; i <= _segmentsW; ++i) {

					revolutionAngle = i * revolutionAngleDelta;
					x = 0.5 + 0.5 * Math.cos(revolutionAngle);
					y = 0.5 + 0.5 * Math.sin(revolutionAngle);

					_rawUvs[currentUvCompIndex++] = 0.5; // ??????????? ???????
					_rawUvs[currentUvCompIndex++] = 0.5;
					_rawUvs[currentUvCompIndex++] = x; // ??????? ???????
					_rawUvs[currentUvCompIndex++] = y;
				}
			}

			// ??????? ???????????
			if(_surfaceClosed)
			{
				for(j = 0; j <= _segmentsH; ++j)
				{
					for(i = 0; i <= _segmentsW; ++i)
					{
						// ??????? ???????
						_rawUvs[currentUvCompIndex++] = i / _segmentsW;
						_rawUvs[currentUvCompIndex++] = j / _segmentsH;
					}
				}
			}

			// ??????? ???????? ?????? ?? ????? ??????
			geometry.setAttributeValues(VertexAttributes.TEXCOORDS[0], _rawUvs);
			addSurface(_material, 0, geometry.indices.length/3);
			calculateBoundBox();
			setMaterialToAllSurfaces(_material);
		}
		
		/**
		 * ?????? ??????? ????? ????????.
		 */
		public function get topRadius() : Number {
			return _topRadius;
		}
		
		/**
		 * ?????? ?????? ????? ????????.
		 */
		public function get bottomRadius() : Number {
			return _bottomRadius;
		}
		
		/**
		 * ?????? ????????.
		 */
		public function get height() : Number {
			return _height;
		}
		
		/**
		 * ?????????? ????????? ?? ??????????? ?? ??????? ??????? ???????. ???????? ?? ????????? ????? 16.
		 */
		public function get segmentsW() : uint {
			return _segmentsW;
		}
		
		/**
		 * ?????????? ????????? ?? ????????? ?? ??????? ??????? ???????. ???????? ?? ????????? ????? 1.
		 */
		public function get segmentsH() : uint {
			return _segmentsH;
		}
		
		/**
		 * ??????? ????? ???????? ???????? (true) ??? ???????? ?
		 */
		public function get topClosed() : Boolean {
			return _topClosed;
		}
		
		/**
		 * ?????? ????? ???????? ???????? (true) ??? ???????? ?
		 */
		public function get bottomClosed() : Boolean {
			return _bottomClosed;
		}
		
		/**
		 * ??????????? ???????? ???????? (true) ??? ???????? ?
		 */
		public function get surfaceClosed() : Boolean {
			return _surfaceClosed;
		}
		
		/**
		 * ??? ????? ?????? ????????, ?? ??? Y(true) ??? ?? ??? Z(false) ?
		 */
		public function get yUp() : Boolean {
			return _yUp;
		}
	}
}